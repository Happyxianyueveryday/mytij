## 第五章：初始化与清理

### 1. 类的构造器与默认构造器
java类的构造器声明和cpp是类似的，均用类名作为构造器名，这里不再重复解释。java同样支持默认构造器和多个重载的构造器。需要特别注意的是，当不声明任何构造器时，java会自动生成类的默认构造器，默认构造器将类的基本类型属性初始化为对应基本类型的默认值，将类的引用属性初始化为null；当声明了任意一个构造器之后，java便不会再生成默认构造器，若需要使用默认构造器，需要编程者手动编写默认构造器。

### 2. java方法重载
java的方法重载原则和cpp基本相同，这里不作过多介绍。
+ 一个函数的参数类型列表称为一个函数的签名，java方法重载就基于函数签名来进行。
需要特别注意，函数的返回值不是函数的签名，也不能用于函数重载，这是因为调用函数时不一定使用函数返回值，这时编译器无法确定调用哪个重载函数，而参数则是调用函数时必须提供的。

### 3. java重载匹配
java在重载匹配上的规则比cpp简单的多，且不容易混淆。如下所示：
+ 对于基本类型，允许从低级到高级的类型提升（例如float到double），但是不允许从高级到低级的类型下降（例如从float到int）。因为类型提升不会带来信息损失，而类型下降可能导致信息和精度的损失。
+ 对于引用类型，若形参类型和实参类型之间存在继承关系，若实参类型低于形参类型，则不匹配；若实参类型高于形参类型，则选择继承链上最接近实参类型的。除了继承关系的情况外，java禁止任何形式的隐式自动类型转换。
得益于如上的规则，java重载匹配不必过多考虑隐式自动转换，因此其重载匹配规则相对于cpp显得简单。

下面提供一个示例。

```
double method1(float param);

method1(3);             // 匹配，float比int高级，类型提升不损失信息
method1((double)3.11);  // 不匹配，double从float高级，类型降低损失信息

Living living;   // 生物类对象
Animal animal;   // 动物类对象
Human human;     // 人类类对象

void method(Animal ani);  

methods2(living);  // 不匹配，形参类型比实参类型更高级，派生类比基类高级
methods2(human);   // 匹配，形参类型比实参类型更低级，基类比派生类低级，这时在继承链上匹配形参参数类型最接近实参参数类型的。
```

实际上只要想清楚A继承B所表达的A属于B的关系，上述问题都是很简单的基础题。

### 4. 类对象的this引用
java类对象中的this引用和cpp中的this指针基本上也是相同的功能，因此不再重复性介绍。强调以下两点：
+ static关键字代表的静态成员方法没有this引用，因此无法访问非静态成员方法和属性。
+ 在派生类中，java还提供了其直接基类的引用super，直接使用super(...)的调用形式即可调用基类构造器进行基类的构造。

### 5. 对象清理与垃圾回收
java中的垃圾回收存在如下三个特点：
1. 对于不再使用的对象，不一定会被垃圾回收。
2. 垃圾回收仅仅清理和释放了原对象所占用的内存，不涉及到其他任何清理工作。
3. 
正是因为如上三个特点，因此存在如下的原则。
+ java的finalize方法不等同于cpp的析构函数，垃圾回收过程也不等同于cpp的析构函数，因为cpp析构函数除了完成释放内存外还可以包含处理其他清理工作的代码。
+ java内存之外的清理工作（例如I/O状态，屏幕显示清理）全部应当由用户自身的自定义方法负责。

### 6. java垃圾回收机制（待补充）


### 7. 类的成员初始化
和cpp类似，java保证每一个类的成员属性都必定由一个初始值。
#### 7.1 类的普通成员的初始化方法和规则
类的普通成员的初始化方法包括：
+ 直接在普通成员的定义中赋初值。
+ 在初始化函数中赋初值。
如果上述两种初始化方法都没有被使用，则java保证基本类型的普通成员属性具有其基本类型的默认值，引用类型的普通成员具有默认值null。

#### 7.2 类的静态成员的初始化方法和规则


#### 7.3 数组成员的初始化方法

