## 第八章：多态

### 1. 多态的基本概念
java的多态机制和cpp类似，概括而言可以得到如下两点：
+ 将基类的引用绑定到基类对象或者该基类派生出的派生类对象上。
+ 使用该基类的引用调用成员方法时，将根据该基类引用所绑定对象的实际类型，调用对应版本的重写函数（虚函数）。

从上述基本概念中可见，触发多态至少需要两个关键点：**基类引用**，**调用虚成员函数**。特别地，这里的基类只要是继承链上相对为止的基类即可。

与cpp略有不同，在java中，默认的成员函数均为虚函数，如果需要设置一个成员方法不作为虚函数，需要使用final关键字。而在cpp中，默认的成员函数均不是虚函数，若需要设置一个成员函数作为虚函数，需要使用virtual关键字。

特别地，在java中调用如下的两类成员方法不会触发多态特性：
+ 类的静态成员方法（static关键字）：使用基类引用进行调用时，会固定调用基类中的同名静态函数。
+ 类的final成员方法（final关键字）：使用基类引用进行调用时，会固定调用基类中的同名final函数。（回顾一下，final成员方法不能被重写，也不具备虚函数特性。）

### 2. 多态的核心原理：动态绑定
多态的核心机制是动态绑定。在强类型编程语言中，将调用方法和调用主体联系的过程称为绑定，分为静态绑定和动态绑定。cpp和java中均同时存在这两种绑定，但有所区别。

在java中的静态绑定和动态绑定如下：
+ 静态绑定：按照调用主体即引用的类型来决定调用哪个成员方法。使用非基类引用，或者调用static，final的成员方法时，发生的绑定均为静态绑定。
+ 动态绑定：按照调用主体所实际绑定的对象类型，即引用所绑定的对象的实际类型来决定调用哪个成员方法。使用基类的引用调用一般的java成员函数（非final，非static）时发生的绑定均为动态绑定。

在cpp中的静态绑定和动态绑定如下：
+ 静态绑定：按照调用主体——指针或者引用的类型来决定调用哪个成员方法。cpp中使用非基类引用或指针，或者调用非虚函数（non-virtual），静态函数时，发生的绑定均为静态绑定。
+ 动态绑定：按照调用主体——指针或者引用实际绑定的对象的类型来决定调用哪个成员方法。cpp中使用基类指针或者引用调用虚函数时发生动态绑定。

不论是cpp还是java，动态绑定发生在运行时，而静态绑定发生在编译时。

可见，cpp和java中在绑定方式上的主要区别是：cpp中默认使用静态绑定，只有使用基类引用/指针调用调用virtual的虚函数时才发生动态绑定。而java中默认使用动态绑定，默认的函数就是虚函数，仅有使用final取消虚函数特性或者调用静态函数时才发生静态绑定。

### 3. 向上转型与向下转型
java的向上转型始终是安全且隐式进行的，将一个派生类对象绑定到基类对象上的操作是绝对安全，且是java中非常常见的语句。

### 4. 多态的典型应用——工厂模式
多态的最典型的一个应用就是工厂模式，工厂模式用于批量生成实现了同一个接口，或者是继承自同一个基类的多种派生类的对象。调用者通过基类或者接口的引用得到返回的不同类型的对象。

#### 4.1 简单工厂模式
下面提供一个示例，这个工厂模式类根据输入的动物名称生成不同的动物类的对象，其中Animal为基类，而Bird，Cat，Dog均为Animal的派生类。

```
public class AnimalFactory
{
    public AnimalFactory()
    {
    }

    public Animal manufacture(String name)
    {
        if(name.equals("bird"))    // 输入为'Bird'，创建Bird对象并返回
        return new Bird();
        else if(name.equals("cat"))// 输入为'Cat'，创建'Cat'对象并返回
        return new Cat();
        else if(name.equals("dog"))// 输入为'Dog'，创建'Dog'对象并返回
        return new Dog();
    }
}
```

### 4.2 工厂方法模式
简单工厂模式的缺陷在于，所有派生类的对象都由基类工厂根据输入的参数进行创建，因此，每次创建一种继承了Animal类的新动物，都必须直接修改工厂类AnimalFactory的manufacture方法，这对于大型工程而言不适合。因此诞生了工厂方法模式。

工厂方法模式将基类和派生类的工厂都声明为接口，首先声明基类的工厂接口，派生类的工厂类实现基类工厂接口，由各个派生类的工厂类直接创建对应派生类的对象，而不是由基类来根据输入创建不同的派生类对象。

下面给出了一个工厂方法模式的示例，其中Cat和Dog均为基类Animal的基类。

'''
public interface AnimalFactory 
{
    Animal manufacture();
}

public class CatFactory implements AnimalFactory
{
    @Override
    Animal manufacture() 
    {
        return new Cat();
    }
}

public class DogFactory implements AnimalFactory
{
    @Override
    Animal manufacture() 
    {
        return new Dog();
    }
}
'''

### 4. 向下转型
在有时即使使用基类引用绑定到派生类对象上，但是还需要使用派生类的特有方法，这时便需要向下转型。
与向上转型的安全性不同，向下转型可能是具有危险的。但是在java中，因为编译器和虚拟机会自动检测向下转型的合法性，因此可以较为简单的使用相加转型，语法和向上转型类似。例如：

```
Animal animal=new Cat();
Cat cat=animal;     // 发生向下转型
(Cat)animal;        // 发生向下转型
```
java中的向下转型较为安全，因此可以经常使用，它是通过RTTI（运行时类型识别）实现的。如果向下转型时类别不匹配，编译器和虚拟机在运行时会报错和抛出异常。

